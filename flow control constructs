!!Before i begin
!!things to keep in mind
!!python do not have switch case construct but there are work arounds mentioned in below document
!!good read about absence of switch case construct in python https://www.pydanny.com/why-doesnt-python-have-switch-case.html


1. if constucts :

  expr : [(] expression_body [)] #eg ( 2 + 3 == 5 )
  actual syntax  : if  expr:
                    **body of if**
                   [elif expr : 
                      **body** ]*
                   [else : 
                      **body** ]?
                      
                      #here  ? : zero or one time
                            * : zero or more times
                            
  Things to keep in mind :
  
  instead of conventional way of using  curly braces to create scopes, python does it by colon symbol ':' 
  and appropriate indentation (tabs generally).
  
  conventionally other languages have used 'else if' construct but python represents it as 'elif' shorthand
  
  2. for construct
  
  for construct in python is somewhat diffrenet from conventional c/java for construct.
  instead of iterating over arthimatic numbers with defined step, pythons for loop iterates over sequence 
  where sequence can be list, string etc.
  
  syntax  : for temp_item_name in sequence : 
                **do something with temp item **
 eg :
  program : 
  list_var = [1, 2, 3]
  string_var = 'complex'
  for num in  list_var : 
    print( num )
  for char in string_var : 
    print( char )
output : 
C:\ProgramData\Anaconda3>python tobedeleted/test.py
1
2
3
c
o
m
p
l
e
x

C:\ProgramData\Anaconda3>
end eg:

--to conventionally iterate over sequence of artimatic numbers one can use sequence generated by range class

class range( start_val = 0, end_val , step = 1 )
-start_val : starting value of sequence
-end_val : ending and excluded value of sequnence ,i.e last value a sequence can have is end_val - 1 !manditory
-step : difference between consecutive sequence values 

range is not a function that returns list of items within given sequence 
read about range : https://docs.python.org/3/library/stdtypes.html?highlight=range#range

in short about range : 
range objects are indexable slicable (negative indexing slicing allowed).

The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory,
no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and 
subranges as needed).

some interesting egs : 

>>> range(5)
range(0, 5)
>>> range_var = range(0 ,10)
>>> type(range_var)
<class 'range'>
>>> range_var[ 0 : ]
range(0, 10)
>>> range_var[ 0 : 5]
range(0, 5)
>>> range_var[3]
3
>>> range_var[10]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: range object index out of range
>>>
>>> list(range_var)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> tuple()
()
>>> tuple(range_var)
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
end EG
!! rememeber kids range is class type and it does not returns the list !!


--for with range

to iterate over sequence of artimatic numbers of defined step
one can use range 

>>> for num in range(5, 15, 3) :
...     print(num, end = " ")
...
5 8 11 14 
>>>
>>> for num in range (-1, 10 , -1): #no op
...     print(num)
...
>>> for num in range (-1, -10) : #no op 
...     print(num)
...
>>> for num in range(-1, -10, -1):
...     print(num, end = " ")
...
-1 -2 -3 -4 -5 -6 -7 -8 -9 
>>> list_var = ['one', 'two', 'three']
>>> for index in range( len(list_var) ):
...     print(index, list_var[index])
...
0 one
1 two
2 three
>>>
!!! it should be noted that if one wants to iterate over iterable along with numeric indexes the enumerate method of looping is recommended   
     over range!!

------ A very important thing when iterating over mutable/iterables, sequences

if code is iterating over a mutable sequence and modifying, adding new items in it too, 
there is a possibility that loop may iterate over it infinitely

eg : 
list_var = [1, 2, 3]

for item in list_var :
    print(item)
    list_var.append( item * 2 )
output : this code will run infinitely
end eg

in above example even if items are inserted at start instead of appending, the code will stil;l run till infinity.
in fact constantly inserting value at some index for each iteration will make it run infintely 

in such cases one should iterate over the copy of iterable object to be modified
one simple and convinient way of achieving that is to make copy of iterable by slicing it as whole

eg :
list_var = [1, 2, 3]

for item in list_var[ : ] :  #this slicing will make sure that loop is iterating over older copy which is not being modified 
    print(item)
    list_var.append( item * 2 )
output :
C:\ProgramData\Anaconda3>python tobedeleted/test.py
1
2
3


